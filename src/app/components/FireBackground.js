'use client';

import { useEffect, useRef } from 'react';

export default function FireBackground({ theme }) {
    const containerRef = useRef(null);

    useEffect(() => {
        const container = containerRef.current;
        if (!container) return;

        // Clear existing particles if any (React strict mode might double init)
        container.innerHTML = '<!-- Particles generated by JS -->';

        const emberCount = 30; // Fast sparks
        const fogCount = 8;    // Slow deep clouds

        // Helper to create particles
        const createParticle = (type) => {
            const particle = document.createElement('div');
            particle.classList.add('fire-particle', type);

            // Randomize initial properties
            const left = Math.random() * 100; // 0% to 100% width
            const drift = (Math.random() - 0.5) * 300 + 'px'; // Horizontal drift

            // Custom properties based on type
            let duration, delay;

            if (type === 'ember') {
                duration = Math.random() * 3 + 2; // 2-5s (Fast)
                delay = Math.random() * 5;
            } else { // Fog
                duration = Math.random() * 10 + 10; // 10-20s (Slow)
                delay = Math.random() * 10;
            }

            // Apply styles
            particle.style.left = `${left}%`;
            particle.style.setProperty('--drift', drift);
            particle.style.animationDuration = `${duration}s`;
            particle.style.animationDelay = `-${delay}s`; // Negative start

            container.appendChild(particle);

            particle.addEventListener('animationiteration', () => {
                // Randomize position for next loop
                const newLeft = Math.random() * 100;
                const newDrift = (Math.random() - 0.5) * 300 + 'px';
                particle.style.left = `${newLeft}%`;
                particle.style.setProperty('--drift', newDrift);

                // Randomize speed slightly
                if (type === 'ember') {
                    particle.style.animationDuration = `${Math.random() * 3 + 2}s`;
                }
            });
        };

        // Create Embers
        for (let i = 0; i < emberCount; i++) {
            createParticle('ember');
        }
        // Create Fog
        for (let i = 0; i < fogCount; i++) {
            createParticle('fog');
        }

        // Interaction State
        let isInteracting = false;
        let animationFrameId;

        // Auto-animation for mobile (when not interacting)
        const animate = () => {
            // Check if mobile (using standard tablet/mobile width or touch capability)
            const isMobile = window.innerWidth <= 768;

            if (isMobile && !isInteracting) {
                const time = Date.now() / 1500;
                // Create a smooth wandering path (Lissajous curve)
                const x = 50 + 35 * Math.sin(time);
                const y = 50 + 35 * Math.cos(time * 1.3);

                container.style.setProperty('--mouse-x', `${x}%`);
                container.style.setProperty('--mouse-y', `${y}%`);
            }

            animationFrameId = requestAnimationFrame(animate);
        };

        // Start loop
        animate();

        // Interaction Handler
        const handleInteraction = (clientX, clientY) => {
            isInteracting = true;
            const x = (clientX / window.innerWidth) * 100;
            const y = (clientY / window.innerHeight) * 100;
            container.style.setProperty('--mouse-x', `${x}%`);
            container.style.setProperty('--mouse-y', `${y}%`);
        };

        const onMouseMove = (e) => handleInteraction(e.clientX, e.clientY);
        const onTouchMove = (e) => handleInteraction(e.touches[0].clientX, e.touches[0].clientY);
        const onTouchStart = (e) => handleInteraction(e.touches[0].clientX, e.touches[0].clientY);

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('touchmove', onTouchMove, { passive: false });
        window.addEventListener('touchstart', onTouchStart, { passive: false });

        return () => {
            window.removeEventListener('mousemove', onMouseMove);
            window.removeEventListener('touchmove', onTouchMove);
            window.removeEventListener('touchstart', onTouchStart);
            cancelAnimationFrame(animationFrameId);
        };
    }, []);

    // Update theme
    useEffect(() => {
        const container = containerRef.current;
        if (!container) return;

        // Remove old theme classes
        container.classList.remove('theme-f', 'theme-l', 'theme-a', 'theme-m', 'theme-e', 'theme-s');

        // Add new theme class if char is valid
        if (theme) {
            const className = `theme-${theme.toLowerCase()}`;
            container.classList.add(className);
        }
    }, [theme]);

    return <div id="fire-background" className="fire-background" ref={containerRef}></div>;
}
